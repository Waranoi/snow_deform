#version 450 core
#define PI 3.1415926538

layout(quads, equal_spacing, ccw) in;

in vec3 es_pos[];
in vec3 es_norm[];
in vec2 es_tex_coord[];

out VERTEX
{
    vec3 norm;
    vec2 tex_coord;
    vec3 color;
} vertex;

uniform float radius = 0;
uniform mat4 proj;
uniform mat4 view;
uniform int width;
uniform int height;
layout (binding = 1) uniform sampler2D height_map;

void main()
{
    vertex.color = vec3(0);
    
    // Interpolate texture coordinates
    float t1 = mix(es_tex_coord[0].x, es_tex_coord[1].x, gl_TessCoord.x);
    float t2 = mix(es_tex_coord[0].y, es_tex_coord[3].y, gl_TessCoord.y);
    vertex.tex_coord = vec2(t1, t2);

    vec3 p;
    if (radius > 0)
    {
        float lat = vertex.tex_coord.x * 2 * PI;
        float lon = vertex.tex_coord.y * PI;

        float x = radius * cos(lat) * sin(lon);
        float y = radius * sin(lat) * sin(lon);
        float z = radius * cos(lon);
        p = vec3(x, y, z);
        vertex.norm = normalize(p);
    }
    else
    {
        // Interpolate along bottom edge using x component of the
        // tessellation coordinate
        vec3 p1 = mix(es_pos[0], es_pos[1], gl_TessCoord.x);
        // Interpolate along top edge using x component of the
        // tessellation coordinate
        vec3 p2 = mix(es_pos[3], es_pos[2], gl_TessCoord.x);
        // Now interpolate those two results using the y component
        // of tessellation coordinate
        p = mix(p1, p2, gl_TessCoord.y);
        vertex.norm = es_norm[0];
    }

    float height = texture(height_map, vertex.tex_coord).x * 10.0;

    vec3 final_pos = p + vertex.norm * height;
    gl_Position = proj * view * vec4(final_pos, 1);

    /*vec2 offset = 1.0 / vec2(width, height);
    vec2 half_offset = 0.5 * offset;
    float h_right = texture(height_map, vertex.tex_coord + vec2(half_offset.x, 0)).r;
    float h_left = texture(height_map, vertex.tex_coord + vec2(-half_offset.x, 0)).r;
    float h_top = texture(height_map, vertex.tex_coord + vec2(0, half_offset.y)).r;
    float h_bot = texture(height_map, vertex.tex_coord + vec2(0, -half_offset.y)).r;
    vec3 terrain_norm = vec3(h_left - h_right, offset.x, h_bot - h_top);
    terrain_norm = normalize(terrain_norm);
    vertex.norm = terrain_norm;*/
    // why does it now work, maybe play around with smooth and flat keywords to see if i can figure out why it doesn't work https://gamedev.stackexchange.com/questions/45387/how-are-vertex-shader-outs-sent-as-inputs-to-the-fragment-shader
}